import { VisualModel } from "@dataspecer/core-v2/visual-model";
import { isSemanticModelClass, SemanticModelClass } from "@dataspecer/core-v2/semantic-model/concepts";
import { isSemanticModelClassUsage, SemanticModelClassUsage } from "@dataspecer/core-v2/semantic-model/usage/concepts";

import { ClassesContextType } from "../../context/classes-context";
import { ModelGraphContextType } from "../../context/model-context";
import { EditClassProfileDialogState } from "./edit-class-profile-dialog-controller";
import { EntityModelRepresentative, EntityRepresentative, representClasses, representClassProfiles, representModels, selectWritableModels, sortRepresentatives } from "../utilities/dialog-utilities";
import { sanitizeDuplicitiesInRepresentativeLabels } from "../../utilities/label";
import { getModelIri } from "../../util/iri-utils";
import { isRelativeIri } from "../utilities/entity-utilities";
import { EntityModel } from "@dataspecer/core-v2";
import { InMemorySemanticModel } from "@dataspecer/core-v2/semantic-model/in-memory";
import { AggregatedEntityWrapper } from "@dataspecer/core-v2/semantic-model/aggregator";

export function createNewProfileClassDialogState(
  classesContext: ClassesContextType,
  graphContext: ModelGraphContextType,
  visualModel: VisualModel | null,
  language: string,
  entity: SemanticModelClass | SemanticModelClassUsage,
): EditClassProfileDialogState {
  const models = [...graphContext.models.values()];
  const availableModels = representModels(visualModel, models);
  const writableModels = representModels(visualModel, selectWritableModels(models));
  const targetModel = writableModels[0];

  const entities = graphContext.aggregatorView.getEntities();

  // Prepare list of class and class profiles we can profile.
  const availableProfiles = sanitizeDuplicitiesInRepresentativeLabels(availableModels, [
    ...representClasses(models, classesContext.classes),
    ...representClassProfiles(entities, models,
      classesContext.profiles.filter(item => isSemanticModelClassUsage(item))),
  ]);
  sortRepresentatives(language, availableProfiles);

  // Find representation of entity to profile.
  const profileOf =
    availableProfiles.find(item => item.identifier === entity.id)
    ?? availableProfiles[0]
    ?? null;

  if (profileOf === null) {
    // TODO: What should we do here?
    throw Error("Can not create dialog.");
  }

  if (isSemanticModelClass(entity)) {
    return createForClass(language, availableModels, writableModels, targetModel, entity, availableProfiles, profileOf);
  } else {
    return createForClassProfile(language, entities, availableModels, writableModels, targetModel, entity, availableProfiles, profileOf);
  }
}

function createForClass(
  language: string,
  availableModels: EntityModelRepresentative<EntityModel>[],
  writableModels: EntityModelRepresentative<InMemorySemanticModel>[],
  targetModel: EntityModelRepresentative<InMemorySemanticModel>,
  entity: SemanticModelClass,
  availableProfiles: EntityRepresentative[],
  profileOf: EntityRepresentative,
) {
  return {
    language,
    availableModels,
    writableModels,
    model: targetModel,
    iri: entity.iri ?? "",
    iriPrefix: getModelIri(targetModel.model),
    isIriAutogenerated: false,
    isIriRelative: isRelativeIri(entity.iri),
    name: entity.name ?? {},
    overrideName: false,
    description: entity.description ?? {},
    overrideDescription: false,
    availableProfiles,
    profileOf,
    usageNote: {},
    overrideUsageNote: false,
    disableOverrideUsageNote: true,
  }
}

function createForClassProfile(
  language: string,
  entities: Record<string, AggregatedEntityWrapper>,
  availableModels: EntityModelRepresentative<EntityModel>[],
  writableModels: EntityModelRepresentative<InMemorySemanticModel>[],
  targetModel: EntityModelRepresentative<InMemorySemanticModel>,
  entity: SemanticModelClassUsage,
  availableProfiles: EntityRepresentative[],
  profileOf: EntityRepresentative,
) {

  // We are profiling a profile, we need to get the effective values.
  const aggregated = entities[entity.id]?.aggregatedEntity;
  if (!isSemanticModelClassUsage(aggregated)) {
    // TODO: What should we do here?
    throw Error("Can not create dialog.");
  }

  return {
    language,
    availableModels,
    writableModels,
    model: targetModel,
    iri: entity.iri ?? "",
    iriPrefix: getModelIri(targetModel.model),
    isIriAutogenerated: false,
    isIriRelative: isRelativeIri(entity.iri),
    name: aggregated.name ?? {},
    overrideName: false,
    description: aggregated.description ?? {},
    overrideDescription: false,
    availableProfiles,
    profileOf,
    usageNote: aggregated.usageNote ?? {},
    overrideUsageNote: false,
    disableOverrideUsageNote: false,
  }
}
