import { LanguageString } from "@dataspecer/core-v2/semantic-model/concepts";
import { EntityState, EntityStateController, createEntityController } from "./entity-utilities";
import { EntityRepresentative } from "./dialog-utilities";
import { MissingEntity, MissingModel, NoWritableModelFound, RuntimeError } from "../../application/error";
import { validationNoProblem } from "./validation-utilities";
import { CmeModel, filterWritableModels } from "../../dataspecer/cme-model";
import { EntityDsIdentifier, ModelDsIdentifier } from "../../dataspecer/entity-model";
import { languageStringToString } from "../../utilities/string";
import { configuration, createLogger } from "../../application";
import { absoluteIriToRelative, isRelativeIri } from "../../utilities/iri";
import { removeFromArray } from "../../utilities/functional";

const LOG = createLogger(import.meta.url);

/**
 * Should be used instead of EntityState for profiles.
 */
export interface EntityProfileState
  <ProfileType extends EntityRepresentative> extends EntityState {

  /**
   * If true, name is changed in this profile.
   */
  overrideName: boolean;

  /**
   * If {@link overrideName} is false, define a source of a name.
   */
  nameSource: ProfileType;

  /**
   * Value of a name from {@link nameSource}.
   */
  nameSourceValue: LanguageString;

  overrideDescription: boolean;

  descriptionSource: ProfileType;

  descriptionSourceValue: LanguageString;

  /**
   * List of entities that can be profiles.
   */
  availableProfiles: ProfileType[];

  profileOf: ProfileType[];

  /**
   * Usage note.
   */
  usageNote: LanguageString;

  overrideUsageNote: boolean;

  /**
   * This can be null as {@link availableUsageNoteSources} can be empty.
   */
  usageNoteSource: ProfileType | null;

  usageNotSourceValue: LanguageString;

  /**
   * We can use only profiles as usage note sources.
   * As a result, this can be empty.
   */
  availableUsageNoteSources: ProfileType[];

  /**
   * We can override profile only when we do profile a profile.
   */
  hideUsageNoteProfile: boolean;

}

/**
 * When creating new profile we start with a single profile.
 */
export function createEntityProfileStateForNewEntityProfile
  <ProfileType extends EntityRepresentative>(
  language: string,
  vocabularies: CmeModel[],
  availableProfiles: ProfileType[],
  profiled: string,
  generateIriFromName: (name: string) => string,
): EntityProfileState<ProfileType> {

  const writableVocabularies = filterWritableModels(vocabularies);
  if (writableVocabularies.length === 0) {
    throw new NoWritableModelFound();
  }
  const selectedVocabulary = writableVocabularies[0];

  const profileOf = availableProfiles
    .find(item => item.identifier === profiled);
  if (profileOf === undefined) {
    LOG.error("Missing profiled representative.", {profiled, availableProfiles});
    throw new RuntimeError("Missing profiled representative.");
  }

  const name = languageStringToString(
    configuration().languagePreferences, language, profileOf.label);
  const iri = createNewProfileIri(
    profileOf.iri, generateIriFromName(name));

  const availableUsageNoteSources =
    profileOf.profileOfIdentifiers.length === 0 ? [] : [profileOf];
  const hasUsageNoteSources = availableUsageNoteSources.length > 0;

  return {
    language,
    allModels: vocabularies,
    availableModels: writableVocabularies,
    model: selectedVocabulary,
    // IRI
    iri,
    isIriAutogenerated: false,
    isIriRelative: true,
    iriValidation: validationNoProblem(),
    availableProfiles: availableProfiles,
    profileOf: [profileOf],
    // Name
    name: profileOf.label,
    overrideName: false,
    nameSource: profileOf,
    nameSourceValue: profileOf.label,
    // Description
    description: profileOf.description,
    overrideDescription: false,
    descriptionSource: profileOf,
    descriptionSourceValue: profileOf.description,
    // Usage note.
    usageNote: {},
    overrideUsageNote: !hasUsageNoteSources,
    usageNoteSource: availableUsageNoteSources[0] ?? null,
    usageNotSourceValue: profileOf.usageNote ?? {},
    availableUsageNoteSources,
    hideUsageNoteProfile: !hasUsageNoteSources,
  };
}

/**
 * Return relative IRI for the new profile.
 */
function createNewProfileIri(
  profiledIri: string | null,
  generatedIri: string,
) {
  if (profiledIri === null) {
    return generatedIri;
  }
  if (isRelativeIri(profiledIri)) {
    return profiledIri;
  }
  return absoluteIriToRelative(profiledIri).relative;
}

/**
 * @returns Items that represent a profile.
 */
function filterProfiles<ProfileType extends EntityRepresentative>(
  items: ProfileType[]): ProfileType[] {
  return items.filter(item => item.profileOfIdentifiers.length > 0);
}

/**
 *
 */
export function createEntityProfileStateForEdit
  <ProfileType extends EntityRepresentative>(
  language: string,
  vocabularies: CmeModel[],
  vocabularyDsIdentifier: ModelDsIdentifier,
  availableProfiles: ProfileType[],
  profiled: string[],
  iri: string,
  name: LanguageString | null,
  nameSourceIdentifier: string | null,
  description: LanguageString | null,
  descriptionSourceIdentifier: string | null,
  usageNote: LanguageString | null,
  usageNoteSourceIdentifier: string | null,
): EntityProfileState<ProfileType> {
  const writableVocabularies = filterWritableModels(vocabularies);
  const selectedVocabulary = writableVocabularies.find(item => item.dsIdentifier === vocabularyDsIdentifier);
  if (selectedVocabulary === undefined) {
    throw new MissingModel(vocabularyDsIdentifier);
  }

  const profileOf = availableProfiles.filter(item => profiled.includes(item.identifier));
  if (profileOf.length === 0) {
    throw new RuntimeError("Missing all profiled entities.");
  }

  // Since we need to have profile value for sources,
  // we use this ona as a default.
  const fallbackProfile = profileOf[0];

  const availableUsageNoteSources = filterProfiles(profileOf);
  const hasUsageNoteSources = availableUsageNoteSources.length > 0;

  const nameSource = profileOf.find(
    item => item.identifier === nameSourceIdentifier
  ) ?? fallbackProfile;

  const descriptionSource = profileOf.find(
    item => item.identifier === descriptionSourceIdentifier
  ) ?? fallbackProfile;

  const usageNoteSource = profileOf.find(
    item => item.identifier === usageNoteSourceIdentifier
  ) ?? null;

  return {
    language,
    allModels: vocabularies,
    availableModels: writableVocabularies,
    model: selectedVocabulary,
    availableProfiles: availableProfiles,
    profileOf: profileOf,
    // IRI
    iri,
    isIriAutogenerated: false,
    isIriRelative: isRelativeIri(iri),
    iriValidation: validationNoProblem(),
    // Name
    name: name ?? {},
    overrideName: name !== null,
    nameSource,
    nameSourceValue: nameSource.label,
    // Description
    description: description ?? {},
    overrideDescription: description !== null,
    descriptionSource,
    descriptionSourceValue: descriptionSource.description,
    // Usage note
    usageNote: usageNote ?? {},
    overrideUsageNote: !hasUsageNoteSources,
    usageNoteSource,
    usageNotSourceValue: usageNoteSource?.usageNote ?? {},
    availableUsageNoteSources,
    hideUsageNoteProfile: !hasUsageNoteSources,
  };
}

export interface EntityProfileStateController<ProfileType extends EntityRepresentative> extends EntityStateController {

  addProfileOf: (value: string) => void;

  removeProfileOf: (value: ProfileType) => void;

  toggleNameOverride: () => void;

  setNameSource: (value: ProfileType) => void;

  toggleDescriptionOverride: () => void;

  setDescriptionSource: (value: ProfileType) => void;

  setUsageNote: (setter: (value: LanguageString) => LanguageString) => void;

  toggleUsageNoteOverride: () => void;

  setUsageNoteSource: (value: ProfileType) => void;

}

export function createEntityProfileController<
  ProfileType extends EntityRepresentative,
  State extends EntityProfileState<ProfileType>>
(
  changeState: (next: State | ((prevState: State) => State)) => void,
  generateIriFromName: (name: string) => string,
): EntityProfileStateController<ProfileType> {

  // We use dummy IRI generator function as we do not generate IRI here.
  const entityController = createEntityController(changeState, generateIriFromName);

  const toggleNameOverride = () => {
    changeState((state) => ({
      ...state,
      overrideName: !state.overrideName,
    }));
  }

  const setNameSource = (value: ProfileType) => {
    changeState((state) => ({
      ...state,
      nameSource: value,
      nameSourceValue: value.label,
    }));
  };

  const toggleDescriptionOverride = () => {
    changeState((state) => ({
      ...state,
      overrideDescription: !state.overrideDescription,
    }));
  }

  const setDescriptionSource = (value: ProfileType) => {
    changeState((state) => ({
      ...state,
      descriptionSource: value,
      descriptionSourceValue: value.description,
    }));
  };

  const addProfileOf = (value: string): void => {
    changeState((state) => {
      const newItem = state.availableProfiles.find(item => item.identifier === value);
      if (newItem === undefined) {
        LOG.error(
          "For identifier of missing entity.",
          { identifier: value, value: state.availableProfiles });
        return state;
      }
      const result = {
        ...state,
        profileOf: [...state.profileOf, newItem],
      };
      // We may have added a profile of a profile.
      // We need to check usage note.
      const isProfile = newItem.profileOfIdentifiers.length > 0;
      if (isProfile) {
        result.availableUsageNoteSources =
          [...result.availableUsageNoteSources, newItem];
        if (result.usageNoteSource === null) {
          // We have had no ability to inherit usage note, but now we have.
          result.usageNoteSource = newItem;
          result.usageNotSourceValue = newItem.usageNote ?? {};
          result.hideUsageNoteProfile = false;
        }
      }
      return result;
    });
  };

  const removeProfileOf = (value: ProfileType): void => {
    changeState((state) => {
      if (state.profileOf.length === 1) {
        LOG.error("Can not remove last profile.");
        return state;
      }
      // We could remove profile used as a source for some entities.
      // We need to copy the values and set a new value.
      const profileOf = removeFromArray(value, state.profileOf);
      const defaultProfileOf = profileOf[0];
      const result = {
        ...state,
        profileOf,
      };
      if (result.nameSource === value) {
        result.name = result.nameSourceValue;
        result.nameSource = defaultProfileOf;
        result.nameSourceValue = defaultProfileOf.label;
        result.overrideName = true;
      }
      if (result.descriptionSource === value) {
        result.description = result.descriptionSourceValue;
        result.descriptionSource = defaultProfileOf;
        result.descriptionSourceValue = defaultProfileOf.description;
        result.overrideDescription = true;
      }
      if (result.usageNoteSource === value) {
        result.usageNote = result.usageNotSourceValue;
        const available = filterProfiles(profileOf);
        if (available.length === 0) {
          // There is nothing we can profile from.
          result.usageNoteSource = null;
          result.usageNotSourceValue = {};
          result.overrideUsageNote = true;
          result.hideUsageNoteProfile = true;
        } else {
          result.usageNoteSource = available[0];
          result.usageNotSourceValue = available[0].usageNote ?? {};
          result.overrideUsageNote = true;
        }
      }
      return result;
    });
  };

  const setUsageNote = (setter: (value: LanguageString) => LanguageString): void => {
    changeState((state) => ({
      ...state,
      usageNote: setter(state.usageNote),
    }));
  };

  const toggleUsageNoteOverride = () => {
    changeState((state) => ({
      ...state,
      overrideUsageNote: !state.overrideUsageNote,
    }));
  }

  const setUsageNoteSource = (value: ProfileType) => {
    changeState((state) => ({
      ...state,
      usageNoteSource: value,
    }));
  };

  return {
    ...entityController,
    toggleNameOverride,
    setNameSource,
    toggleDescriptionOverride,
    setDescriptionSource,
    addProfileOf,
    removeProfileOf,
    setUsageNote,
    toggleUsageNoteOverride,
    setUsageNoteSource,
  };
}

export function findProfile<ProfileType extends EntityRepresentative>(
  availableProfiles: ProfileType[],
  identifier: EntityDsIdentifier,
): ProfileType {
  const result = availableProfiles.find(item => item.identifier === identifier);
  if (result === undefined) {
    throw new MissingEntity(identifier);
  }
  return result;
}
