import { VisualModel } from "@dataspecer/core-v2/visual-model";
import { ClassesContextType } from "../../context/classes-context";
import { ModelGraphContextType } from "../../context/model-context";
import { SemanticModelRelationship } from "@dataspecer/core-v2/semantic-model/concepts";
import { isSemanticModelClassUsage, isSemanticModelRelationshipUsage, SemanticModelRelationshipUsage } from "@dataspecer/core-v2/semantic-model/usage/concepts";
import { CreateAttributeProfileDialogState } from "./edit-attribute-profile-dialog-controller";
import { isRepresentingAttribute, representCardinalities, representCardinality, representClasses, representClassProfiles, representDataTypes, representModels, representOwlThing, representRelationshipProfiles, representRelationships, representUndefinedCardinality, representUndefinedDataType, selectWritableModels, sortRepresentatives } from "../utilities/dialog-utilities";
import { sanitizeDuplicitiesInRepresentativeLabels } from "../../utilities/label";
import { getDomainAndRange } from "../../util/relationship-utils";
import { getModelIri } from "../../util/iri-utils";
import { isRelativeIri } from "../utilities/entity-utilities";
import { validationNoProblem } from "../utilities/validation-utilities";


export function createNewAttributeProfileDialogState(
  classesContext: ClassesContextType,
  graphContext: ModelGraphContextType,
  visualModel: VisualModel | null,
  language: string,
  entity: SemanticModelRelationship | SemanticModelRelationshipUsage,
): CreateAttributeProfileDialogState {
  const models = [...graphContext.models.values()];
  const availableModels = representModels(visualModel, models);
  const writableModels = representModels(visualModel, selectWritableModels(models));
  const targetModel = writableModels[0];

  const entities = graphContext.aggregatorView.getEntities();

  // Prepare list of Attributes and class profiles we can profile.
  const availableProfiles = sanitizeDuplicitiesInRepresentativeLabels(availableModels, [
    ...representRelationships(models,
      classesContext.relationships),
    ...representRelationshipProfiles(entities, models,
      classesContext.profiles.filter(item => isSemanticModelRelationshipUsage(item))),
  ]).filter(isRepresentingAttribute);
  sortRepresentatives(language, availableProfiles);

  // Prepare list of class and class profiles we can profile.
  const availableClassProfiles = sanitizeDuplicitiesInRepresentativeLabels(availableModels, [
    ...representClasses(models, classesContext.classes),
    ...representClassProfiles(entities, models,
      classesContext.profiles.filter(item => isSemanticModelClassUsage(item))),
  ]);
  sortRepresentatives(language, availableProfiles);

  const availableDataTypes = representDataTypes();
  sortRepresentatives(language, availableDataTypes);

  // Find representation of entity to profile.
  const profileOf =
    availableProfiles.find(item => item.identifier === entity.id)
    ?? availableProfiles[0]
    ?? null;

  if (profileOf === null) {
    // TODO: What should we do here?
    throw Error("Can not create dialog.");
  }

  const owlThing = representOwlThing();

  const undefinedDataTyp = representUndefinedDataType();

  // Rest of this function depends of what we are profiling.
  const isProfilingProfile = profileOf.profileOfIdentifiers.length > 0;
  if (isProfilingProfile) {
    // We are profiling a profile, we need to get the effective values.
    const aggregated = entities[entity.id]?.aggregatedEntity;
    if (!isSemanticModelRelationshipUsage(aggregated)) {
      // TODO: What should we do here?
      throw Error("Can not create dialog.");
    }

    const { domain, range } = getDomainAndRange(aggregated);

    const domainRepresentation = availableClassProfiles
      .find(item => item.identifier === domain?.concept) ?? owlThing;

    const rangeRepresentation = availableDataTypes
      .find(item => item.identifier === range?.concept) ?? undefinedDataTyp;

    const availableCardinalities = [...representCardinalities()];

    // There may be no cardinality for inherited value.
    // We need a default, when user switch to inherit value.
    const domainCardinality = domain?.cardinality === null ?
      availableCardinalities[0] : representCardinality(domain?.cardinality);
    const rangeCardinality = range?.cardinality === null ?
      availableCardinalities[0] : representCardinality(range?.cardinality);

    return {
      language,
      availableModels,
      writableModels,
      model: targetModel,
      iri: range?.iri ?? "",
      iriPrefix: getModelIri(targetModel.model),
      isIriAutogenerated: false,
      isIriRelative: isRelativeIri(range?.iri),
      name: range?.name ?? {},
      overrideName: false,
      description: range?.description ?? {},
      overrideDescription: false,
      availableProfiles,
      profileOf,
      usageNote: {},
      overrideUsageNote: false,
      disableOverrideUsageNote: false,
      domain: domainRepresentation,
      initialDomain: domainRepresentation,
      overrideDomain: false,
      domainValidation: validationNoProblem(),
      domainCardinality,
      initialDomainCardinality: domainCardinality,
      overrideDomainCardinality: false,
      domainCardinalityValidation: validationNoProblem(),
      availableDomainItems: [owlThing, ...availableClassProfiles],
      range: rangeRepresentation,
      initialRange: rangeRepresentation,
      overrideRange: false,
      rangeValidation: validationNoProblem(),
      rangeCardinality,
      overrideRangeCardinality: false,
      initialRangeCardinality: rangeCardinality,
      rangeCardinalityValidation: validationNoProblem(),
      availableRangeItems: [undefinedDataTyp, ...availableDataTypes],
      availableCardinalities: [representUndefinedCardinality(), ...representCardinalities()],
    };
  } else {
    // We profile an Attribute, little help for TypeScript as well.
    const { domain, range } = getDomainAndRange(entity as SemanticModelRelationship);

    const domainRepresentation = availableClassProfiles
      .find(item => item.identifier === domain?.concept) ?? owlThing;

    const rangeRepresentation = availableDataTypes
      .find(item => item.identifier === range?.concept) ?? undefinedDataTyp;

    const domainCardinality = representCardinality(domain?.cardinality);

    const rangeCardinality = representCardinality(range?.cardinality);

    return {
      language,
      availableModels,
      writableModels,
      model: targetModel,
      iri: range?.iri ?? "",
      iriPrefix: getModelIri(targetModel.model),
      isIriAutogenerated: false,
      isIriRelative: isRelativeIri(range?.iri),
      name: range?.name ?? {},
      overrideName: false,
      description: range?.description ?? {},
      overrideDescription: false,
      availableProfiles,
      profileOf,
      usageNote: {},
      overrideUsageNote: true,
      disableOverrideUsageNote: true,
      domain: domainRepresentation,
      initialDomain: domainRepresentation,
      overrideDomain: false,
      domainValidation: validationNoProblem(),
      domainCardinality,
      initialDomainCardinality: domainCardinality,
      overrideDomainCardinality: false,
      domainCardinalityValidation: validationNoProblem(),
      availableDomainItems: [owlThing, ...availableClassProfiles],
      range: rangeRepresentation,
      initialRange: rangeRepresentation,
      overrideRange: false,
      rangeValidation: validationNoProblem(),
      rangeCardinality,
      overrideRangeCardinality: false,
      initialRangeCardinality: rangeCardinality,
      rangeCardinalityValidation: validationNoProblem(),
      availableRangeItems: [undefinedDataTyp, ...availableDataTypes],
      availableCardinalities: [representUndefinedCardinality(), ...representCardinalities()],
    };
  }
}
